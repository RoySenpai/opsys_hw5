# Operation Systems (OSs) Course Assignment 5

### For Computer Science B.S.c Ariel University

**By Roy Simanovich and Linor Ronen**

## Description
In this assignment we created a program that simulates a pipeline of active objects that communicate
with each other using a queue. The program is written in C and uses POSIX threads and semaphores.

The pipeline consists of 4 active objects (threads) that communicate with each other using a queue:
* **Producer (Active Object 1)** – Generates random numbers and sends them to the queue of the first consumer.
* **First Consumer (Active Object 2)** – Receives numbers from the producer, checks if they are prime numbers, adds 11 to them
and sends them to the queue of the second consumer.
* **Second Consumer (Active Object 3)** – Receives numbers from the first consumer, checks if they are prime numbers, subtracts 13 from them
and sends them to the queue of the third consumer.
* **Third Consumer (Active Object 4)** – Receives numbers from the second consumer, checks if they are prime numbers, adds 2
to them and prints them. The printed number should be the same as the number generated by the producer.

The Queue API, which is thread safe, supports the following operations:
* `PQueue queueCreate()` – Creates a new queue.
* `void queueDestroy(PQueue queue)` – Destroys a queue.
* `void queueEnqueue(PQueue queue, void *data)` – Adds an item to the queue.
* `void *queueDequeue(PQueue queue)` – Removes an item from the queue.
* `int queueIsEmpty(PQueue queue)` – Checks if the queue is empty.

The Active Object API supports the following operations:
* `PActiveObject CreateActiveObject(PQueueFunc func)` – Creates a new active object, a new queue and starts the active object thread.
* `PQueue getQueue(PActiveObject activeObject)` – Returns the queue of the active object.
* `void stopActiveObject(PActiveObject activeObject)` – Stops the active object thread and destroys the queue.

Each active object receives a function pointer to a function that will be executed by the active object thread.
The signature of the handler function is: ```int handler(void *task)```, where task is the data that was dequeued from the queue.

The whole assignment was written in C, and supports the following features:
* **Thread Safety** – The queue is thread safe, and can be used by multiple threads simultaneously.
* **Memory Management** – The queue and the active objects are allocated dynamically, and are freed when they are no longer needed.
* **Error Handling** – The program handles errors and exits gracefully.
* **Simple API** – Both the queue and the active object APIs are simple and easy to use.
* **Documentation** – The program and the API are documented using Doxygen style comments.
* **Performance** – The APIs design and the implementation are efficient and fast.
* **Portability** – The program and the APIs are portable, and can be used on any Linux machine, with any GNU C Compiler, and any Make version, as long as the machine supports POSIX threads.

## Requirements
* Linux machine (Ubuntu 22.04 LTS preferable)
* GNU C Compiler
* Make

## Building
```
# Cloning the repo to local machine.
git clone https://github.com/RoySenpai/opsys_hw5.git

# Building all the necessary files & the main programs.
make all
```

## Running
```
# Run the program
./st_pipeline
```