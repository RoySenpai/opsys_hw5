# Operation Systems (OSs) Course Assignment 5

### For Computer Science B.S.c Ariel University

**By Roy Simanovich and Linor Ronen**

## Description
In this assignment we created a program that simulates a pipeline of active objects that communicate
with each other using a queue. The program is written in C and uses POSIX threads.

The are four main parts in the program:
* **Task** – A simple struct that represents a task.
* **Queue** – A thread safe queue that can be used by multiple threads simultaneously, with blocking operations.
* **Active Object** – An active object that runs in a separate thread and executes a handler function.
* **Pipeline** – A pipeline of active objects that communicate with each other using a queue. The st_pipeline program is an example of a pipeline between 4 active objects.

The pipeline consists of 4 active objects (threads) that communicate with each other using a queue:
* **Producer (Active Object 1)** – Generates random numbers and sends them to the queue of the first consumer.
* **First Consumer (Active Object 2)** – Receives numbers from the producer, checks if they are prime numbers, adds 11 to them
and sends them to the queue of the second consumer.
* **Second Consumer (Active Object 3)** – Receives numbers from the first consumer, checks if they are prime numbers, subtracts 13 from them
and sends them to the queue of the third consumer.
* **Third Consumer (Active Object 4)** – Receives numbers from the second consumer, checks if they are prime numbers, adds 2
to them and prints them. The printed number should be the same as the number generated by the producer.

### Deep Dive
The program uses the following APIs:
* **Task API** – A simple API that represents a task.
* **Queue API** – A thread safe queue API.
* **Active Object API** – An API that represents an active object.

#### Task API
The Task API supports the following operations:
* `PTask createTask(unsigned int num_of_tasks, unsigned int _data)` – Creates a new task with the given data (num_of_tasks and _data), allocates memory for it and returns a pointer to the task.
* `void taskDestroy(PTask task)` – Destroys a task - frees the memory allocated for the task.

The Task struct has the following fields:
* `unsigned int num_of_tasks` – The number of tasks that the task has been through.
* `unsigned int _data` – The data of the task. In this assignment, the data is a number: It's used by the producer to generate a random number,
and by the consumers to check if the number is prime, and to add or subtract a number from it.

**_NOTE_:** The Task struct is specifically designed for this assignment, but it can be used for other purposes as well, with minor changes to the code.

#### Queue API
The Queue API, which is thread safe, supports the following operations:
* `PQueue queueCreate()` – Creates a new queue and returns a pointer to the queue.
* `void queueDestroy(PQueue queue)` – Destroys a queue - destroys all the nodes in the queue and frees the memory allocated for the queue.
* `void queueEnqueue(PQueue queue, void *data)` – Adds an item to the queue (the item is a generic pointer that can point to any type of data).
* `void *queueDequeue(PQueue queue)` – Removes an item from the queue and returns it (the item is a generic pointer that can point to any type of data).
* `int queueIsEmpty(PQueue queue)` – Checks if the queue is empty (returns 1 if the queue is empty, 0 otherwise).
* `int queueSize(PQueue queue)` – Returns the size of the queue (number of items in the queue). Defined only if ```DEBUG_MESSAGES``` is set to 1.
* `void *queuePeek(PQueue queue)` – A debug function that returns the head of the queue, without removing it from the queue and without changing the queue. Defined only if ```DEBUG_MESSAGES``` is set to 1.
* `void *queuePeekTail(PQueue queue)` – A debug function that returns the tail of the queue, without removing it from the queue and without changing the queue. Defined only if ```DEBUG_MESSAGES``` is set to 1.
* `void queuePrint(PQueue queue)` – A debug function that prints the queue. Defined only if ```DEBUG_MESSAGES``` is set to 1.

The Queue struct is defined as follows:
* `PQueueNode head` – A pointer to the head of the queue. The head is the first item that was added to the queue, and this field is used to remove items from the queue efficiently in O(1) time.
* `PQueueNode tail` – A pointer to the tail of the queue. The tail is the last item that was added to the queue, and this field is used to add items to the queue efficiently in O(1) time.
* `unsigned int size` – The size of the queue (number of items in the queue). This field is used to check if the queue is empty, and to get the size of the queue in O(1) time.
* `pthread_mutex_t lock` – A mutex lock that is used to lock the queue when it's being used by a thread. This field is used to make the queue thread safe.
* `pthread_cond_t cond` – A condition variable that is used to signal threads that are waiting for the queue to be unlocked. This field is used to make the queue a blocking queue.

Each queue node has the following fields:
* `void *data` – The data of the node. This is a generic pointer that can point to any type of data.
* `PQueueNode next` – A pointer to the next node in the queue. This field defines the node structure, as a singly linked list.

**_NOTE_:** The queue API is generic, and can be used to create a queue of any type of data. In this assignment, the queue is used to create a queue of tasks. Please note
that the queue API is not type safe, and the user must make sure that the data that is added to the queue is of the correct type.

**_NOTE_:** It is recommended to use the macros defined in the ```Queue.h``` file to enqueue and dequeue items from the queue. The macros are defined as follows:
* `ENQUEUE(queue, data)` – Enqueues an item to the queue. The item is a generic pointer that can point to any type of data.
* `DEQUEUE(queue, type)` – Dequeues an item from the queue and returns it with the correct type. The type is the type of the data that was added to the queue.

**_NOTE_:** For debugging purposes, the user can set the ```DEBUG_MESSAGES``` macro to 1 in the ```Task.h``` file. This will enable the user to use the `queuePeek` and `queuePeekTail` functions to
peek at the head and tail of the queue, without removing them from the queue. This is useful for debugging purposes, as it allows the user to see the queue contents without
changing the queue, while allowing the queue to be thread safe. This also enables the macros for the functions. The macros are defined as follows:
* `PEEK(queue, type)` – Peeks at the head of the queue and returns it with the correct type. The type is the type of the data that was added to the queue.
* `PEEK_TAIL(queue, type)` – Peeks at the tail of the queue and returns it with the correct type. The type is the type of the data that was added to the queue.

**_NOTE_:** Please note that direct access to the queue struct fields is **not allowed**, and the user must use the Queue API to do any operation on the queue,
as the functions that enqueue and dequeue items from the queue are what make the queue thread safe in the first place.

#### Active Object API
The Active Object API supports the following operations:
* `PActiveObject CreateActiveObject(PQueueFunc func)` – Creates a new active object, a new queue and starts the active object thread. Returns a pointer to the active object if
the operation was successful, or NULL if an error occurred.
* `PQueue getQueue(PActiveObject activeObject)` – Returns the queue of the active object, or NULL if an error occurred.
* `void stopActiveObject(PActiveObject activeObject)` – Stops the active object thread, destroys the queue and frees the memory allocated for the active object.
* `void *activeObjectRunFunction(void *activeObject)` – The function that is executed by the active object thread. This function is responsible for dequeuing tasks from the queue and executing them,
not to be called by the user directly.

The Active Object struct has the following fields:
* `unsigned int id` – The id of the active object, for debugging purposes.
* `pthread_t thread` – The thread of the active object. Users can use this field to join the thread, but not to cancel it. To cancel the thread, use the stopActiveObject function.
* `PQueue queue` – The queue of the active object, which holds the tasks that the active object will execute.
* `PQueueFunc func` – A function pointer to the handler function of the active object, which will be executed by the active object thread anytime there is a task in the queue.

Each active object receives a function pointer to a function that will be executed by the active object thread. The signature of the handler
function is: ```int handler_function(void *task)```, where task is the data that was dequeued from the queue. The handler function must
return 1 if the active object should continue running, or 0 if the active object should stop running. The handler function is responsible for
freeing the memory allocated for the task, and for handling any errors that may occur during the execution of the task.

### Additional Information
The whole assignment was written in C, and supports the following features:
* **Thread Safety** – The queue is thread safe, and can be used by multiple threads simultaneously.
* **Memory Management** – The queue and the active objects are allocated dynamically, and are freed when they are no longer needed.
* **Error Handling** – The program handles errors and exits gracefully.
* **Simple API** – Both the queue and the active object APIs are simple and easy to use.
* **Documentation** – The program and the API are documented using Doxygen style comments.
* **Performance** – The APIs design and the implementation are efficient and fast.
* **Portability** – The program and the APIs are portable, and can be used on any Linux machine, with any GNU C Compiler, and any Make version, as long as the machine supports POSIX threads.

The assignment uses the following libraries:
* **stdio** – The standard input/output library, which is used for printing to the console.
* **stdlib** – The standard library, which is used for memory management.
* **errno** – The error handling library, which is used for error handling.
* **pthread** – The POSIX threads library, which is used to create and manage threads.
* **signal** – The signal library, which is used for signal handling.
* **string** – The string library, which is used for string manipulation.
* **unistd** – The standard symbolic constants and types library, which is used for POSIX API access.

The assignment was tested on Ubuntu 22.04 LTS, with GNU C Compiler version 11.2.0, and Make version 4.3. The program was tested with valgrind, and no memory leaks were found.

For more information, please refer to the documentation in the code.

## Requirements
* Linux machine (Ubuntu 22.04 LTS preferable)
* GNU C Compiler
* Make

## Building
```
# Cloning the repo to local machine.
git clone https://github.com/RoySenpai/opsys_hw5.git

# Building all the necessary files & the main programs.
make all
```

## Running
```
# Run the program
./st_pipeline
```